//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
// Generated by T4 (TextTransform.exe) from the file IJobForEach.tt 
//

using Unity.Collections;
using Unity.Collections.LowLevel.Unsafe;
using Unity.Jobs;
using Unity.Jobs.LowLevel.Unsafe;
using System.Runtime.InteropServices;
using UnityEngine.Scripting;
using System;

namespace Unity.Entities
{

#if !UNITY_ZEROPLAYER
    [JobProducerType(typeof(JobForEachExtensions.JobStruct_Process_D<,>))]
#endif
    public interface IJobForEach<U0> : JobForEachExtensions.IBaseJobForEach_D
            where U0 : struct, IComponentData
    {
        void Execute(ref U0 c0);
    }

#if !UNITY_ZEROPLAYER
    [JobProducerType(typeof(JobForEachExtensions.JobStruct_Process_ED<,>))]
#endif
    public interface IJobForEachWithEntity<U0> : JobForEachExtensions.IBaseJobForEach_ED
            where U0 : struct, IComponentData
    {
        void Execute(Entity entity, int index, ref U0 c0);
    }

#if !UNITY_ZEROPLAYER
    [JobProducerType(typeof(JobForEachExtensions.JobStruct_Process_DD<,,>))]
#endif
    public interface IJobForEach<U0, U1> : JobForEachExtensions.IBaseJobForEach_DD
            where U0 : struct, IComponentData
            where U1 : struct, IComponentData
    {
        void Execute(ref U0 c0, ref U1 c1);
    }

#if !UNITY_ZEROPLAYER
    [JobProducerType(typeof(JobForEachExtensions.JobStruct_Process_EDD<,,>))]
#endif
    public interface IJobForEachWithEntity<U0, U1> : JobForEachExtensions.IBaseJobForEach_EDD
            where U0 : struct, IComponentData
            where U1 : struct, IComponentData
    {
        void Execute(Entity entity, int index, ref U0 c0, ref U1 c1);
    }

#if !UNITY_ZEROPLAYER
    [JobProducerType(typeof(JobForEachExtensions.JobStruct_Process_DDD<,,,>))]
#endif
    public interface IJobForEach<U0, U1, U2> : JobForEachExtensions.IBaseJobForEach_DDD
            where U0 : struct, IComponentData
            where U1 : struct, IComponentData
            where U2 : struct, IComponentData
    {
        void Execute(ref U0 c0, ref U1 c1, ref U2 c2);
    }

#if !UNITY_ZEROPLAYER
    [JobProducerType(typeof(JobForEachExtensions.JobStruct_Process_EDDD<,,,>))]
#endif
    public interface IJobForEachWithEntity<U0, U1, U2> : JobForEachExtensions.IBaseJobForEach_EDDD
            where U0 : struct, IComponentData
            where U1 : struct, IComponentData
            where U2 : struct, IComponentData
    {
        void Execute(Entity entity, int index, ref U0 c0, ref U1 c1, ref U2 c2);
    }

#if !UNITY_ZEROPLAYER
    [JobProducerType(typeof(JobForEachExtensions.JobStruct_Process_DDDD<,,,,>))]
#endif
    public interface IJobForEach<U0, U1, U2, U3> : JobForEachExtensions.IBaseJobForEach_DDDD
            where U0 : struct, IComponentData
            where U1 : struct, IComponentData
            where U2 : struct, IComponentData
            where U3 : struct, IComponentData
    {
        void Execute(ref U0 c0, ref U1 c1, ref U2 c2, ref U3 c3);
    }

#if !UNITY_ZEROPLAYER
    [JobProducerType(typeof(JobForEachExtensions.JobStruct_Process_EDDDD<,,,,>))]
#endif
    public interface IJobForEachWithEntity<U0, U1, U2, U3> : JobForEachExtensions.IBaseJobForEach_EDDDD
            where U0 : struct, IComponentData
            where U1 : struct, IComponentData
            where U2 : struct, IComponentData
            where U3 : struct, IComponentData
    {
        void Execute(Entity entity, int index, ref U0 c0, ref U1 c1, ref U2 c2, ref U3 c3);
    }

#if !UNITY_ZEROPLAYER
    [JobProducerType(typeof(JobForEachExtensions.JobStruct_Process_DDDDD<,,,,,>))]
#endif
    public interface IJobForEach<U0, U1, U2, U3, U4> : JobForEachExtensions.IBaseJobForEach_DDDDD
            where U0 : struct, IComponentData
            where U1 : struct, IComponentData
            where U2 : struct, IComponentData
            where U3 : struct, IComponentData
            where U4 : struct, IComponentData
    {
        void Execute(ref U0 c0, ref U1 c1, ref U2 c2, ref U3 c3, ref U4 c4);
    }

#if !UNITY_ZEROPLAYER
    [JobProducerType(typeof(JobForEachExtensions.JobStruct_Process_EDDDDD<,,,,,>))]
#endif
    public interface IJobForEachWithEntity<U0, U1, U2, U3, U4> : JobForEachExtensions.IBaseJobForEach_EDDDDD
            where U0 : struct, IComponentData
            where U1 : struct, IComponentData
            where U2 : struct, IComponentData
            where U3 : struct, IComponentData
            where U4 : struct, IComponentData
    {
        void Execute(Entity entity, int index, ref U0 c0, ref U1 c1, ref U2 c2, ref U3 c3, ref U4 c4);
    }

#if !UNITY_ZEROPLAYER
    [JobProducerType(typeof(JobForEachExtensions.JobStruct_Process_DDDDDD<,,,,,,>))]
#endif
    public interface IJobForEach<U0, U1, U2, U3, U4, U5> : JobForEachExtensions.IBaseJobForEach_DDDDDD
            where U0 : struct, IComponentData
            where U1 : struct, IComponentData
            where U2 : struct, IComponentData
            where U3 : struct, IComponentData
            where U4 : struct, IComponentData
            where U5 : struct, IComponentData
    {
        void Execute(ref U0 c0, ref U1 c1, ref U2 c2, ref U3 c3, ref U4 c4, ref U5 c5);
    }

#if !UNITY_ZEROPLAYER
    [JobProducerType(typeof(JobForEachExtensions.JobStruct_Process_EDDDDDD<,,,,,,>))]
#endif
    public interface IJobForEachWithEntity<U0, U1, U2, U3, U4, U5> : JobForEachExtensions.IBaseJobForEach_EDDDDDD
            where U0 : struct, IComponentData
            where U1 : struct, IComponentData
            where U2 : struct, IComponentData
            where U3 : struct, IComponentData
            where U4 : struct, IComponentData
            where U5 : struct, IComponentData
    {
        void Execute(Entity entity, int index, ref U0 c0, ref U1 c1, ref U2 c2, ref U3 c3, ref U4 c4, ref U5 c5);
    }

    public static partial class JobForEachExtensions
    { 
#if !UNITY_ZEROPLAYER                           
        public static JobHandle Schedule<T>(this T jobData, ComponentSystemBase system, JobHandle dependsOn = default(JobHandle))
            where T : struct, IBaseJobForEach
        {
            var typeT = typeof(T);
            if (typeof(IBaseJobForEach_D).IsAssignableFrom(typeT))
                return ScheduleInternal_D(ref jobData, system, null, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_ED).IsAssignableFrom(typeT))
                return ScheduleInternal_ED(ref jobData, system, null, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_DD).IsAssignableFrom(typeT))
                return ScheduleInternal_DD(ref jobData, system, null, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_EDD).IsAssignableFrom(typeT))
                return ScheduleInternal_EDD(ref jobData, system, null, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_DDD).IsAssignableFrom(typeT))
                return ScheduleInternal_DDD(ref jobData, system, null, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_EDDD).IsAssignableFrom(typeT))
                return ScheduleInternal_EDDD(ref jobData, system, null, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_DDDD).IsAssignableFrom(typeT))
                return ScheduleInternal_DDDD(ref jobData, system, null, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_EDDDD).IsAssignableFrom(typeT))
                return ScheduleInternal_EDDDD(ref jobData, system, null, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_DDDDD).IsAssignableFrom(typeT))
                return ScheduleInternal_DDDDD(ref jobData, system, null, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_EDDDDD).IsAssignableFrom(typeT))
                return ScheduleInternal_EDDDDD(ref jobData, system, null, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_DDDDDD).IsAssignableFrom(typeT))
                return ScheduleInternal_DDDDDD(ref jobData, system, null, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_EDDDDDD).IsAssignableFrom(typeT))
                return ScheduleInternal_EDDDDDD(ref jobData, system, null, 1, dependsOn, ScheduleMode.Batched);
            throw new System.ArgumentException("Not supported");
        }
#endif
#if !UNITY_ZEROPLAYER                           
        public static JobHandle ScheduleSingle<T>(this T jobData, ComponentSystemBase system, JobHandle dependsOn = default(JobHandle))
            where T : struct, IBaseJobForEach
        {
            var typeT = typeof(T);
            if (typeof(IBaseJobForEach_D).IsAssignableFrom(typeT))
                return ScheduleInternal_D(ref jobData, system, null, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_ED).IsAssignableFrom(typeT))
                return ScheduleInternal_ED(ref jobData, system, null, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_DD).IsAssignableFrom(typeT))
                return ScheduleInternal_DD(ref jobData, system, null, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_EDD).IsAssignableFrom(typeT))
                return ScheduleInternal_EDD(ref jobData, system, null, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_DDD).IsAssignableFrom(typeT))
                return ScheduleInternal_DDD(ref jobData, system, null, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_EDDD).IsAssignableFrom(typeT))
                return ScheduleInternal_EDDD(ref jobData, system, null, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_DDDD).IsAssignableFrom(typeT))
                return ScheduleInternal_DDDD(ref jobData, system, null, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_EDDDD).IsAssignableFrom(typeT))
                return ScheduleInternal_EDDDD(ref jobData, system, null, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_DDDDD).IsAssignableFrom(typeT))
                return ScheduleInternal_DDDDD(ref jobData, system, null, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_EDDDDD).IsAssignableFrom(typeT))
                return ScheduleInternal_EDDDDD(ref jobData, system, null, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_DDDDDD).IsAssignableFrom(typeT))
                return ScheduleInternal_DDDDDD(ref jobData, system, null, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_EDDDDDD).IsAssignableFrom(typeT))
                return ScheduleInternal_EDDDDDD(ref jobData, system, null, -1, dependsOn, ScheduleMode.Batched);
            throw new System.ArgumentException("Not supported");
        }
#endif
#if !UNITY_ZEROPLAYER                           
        public static JobHandle Run<T>(this T jobData, ComponentSystemBase system, JobHandle dependsOn = default(JobHandle))
            where T : struct, IBaseJobForEach
        {
            var typeT = typeof(T);
            if (typeof(IBaseJobForEach_D).IsAssignableFrom(typeT))
                return ScheduleInternal_D(ref jobData, system, null, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_ED).IsAssignableFrom(typeT))
                return ScheduleInternal_ED(ref jobData, system, null, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_DD).IsAssignableFrom(typeT))
                return ScheduleInternal_DD(ref jobData, system, null, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_EDD).IsAssignableFrom(typeT))
                return ScheduleInternal_EDD(ref jobData, system, null, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_DDD).IsAssignableFrom(typeT))
                return ScheduleInternal_DDD(ref jobData, system, null, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_EDDD).IsAssignableFrom(typeT))
                return ScheduleInternal_EDDD(ref jobData, system, null, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_DDDD).IsAssignableFrom(typeT))
                return ScheduleInternal_DDDD(ref jobData, system, null, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_EDDDD).IsAssignableFrom(typeT))
                return ScheduleInternal_EDDDD(ref jobData, system, null, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_DDDDD).IsAssignableFrom(typeT))
                return ScheduleInternal_DDDDD(ref jobData, system, null, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_EDDDDD).IsAssignableFrom(typeT))
                return ScheduleInternal_EDDDDD(ref jobData, system, null, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_DDDDDD).IsAssignableFrom(typeT))
                return ScheduleInternal_DDDDDD(ref jobData, system, null, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_EDDDDDD).IsAssignableFrom(typeT))
                return ScheduleInternal_EDDDDDD(ref jobData, system, null, -1, dependsOn, ScheduleMode.Run);
            throw new System.ArgumentException("Not supported");
        }
#endif

#if !UNITY_ZEROPLAYER                           
        public static JobHandle Schedule<T>(this T jobData, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where T : struct, IBaseJobForEach
        {
            var typeT = typeof(T);
            if (typeof(IBaseJobForEach_D).IsAssignableFrom(typeT))
                return ScheduleInternal_D(ref jobData, null, query, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_ED).IsAssignableFrom(typeT))
                return ScheduleInternal_ED(ref jobData, null, query, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_DD).IsAssignableFrom(typeT))
                return ScheduleInternal_DD(ref jobData, null, query, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_EDD).IsAssignableFrom(typeT))
                return ScheduleInternal_EDD(ref jobData, null, query, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_DDD).IsAssignableFrom(typeT))
                return ScheduleInternal_DDD(ref jobData, null, query, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_EDDD).IsAssignableFrom(typeT))
                return ScheduleInternal_EDDD(ref jobData, null, query, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_DDDD).IsAssignableFrom(typeT))
                return ScheduleInternal_DDDD(ref jobData, null, query, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_EDDDD).IsAssignableFrom(typeT))
                return ScheduleInternal_EDDDD(ref jobData, null, query, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_DDDDD).IsAssignableFrom(typeT))
                return ScheduleInternal_DDDDD(ref jobData, null, query, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_EDDDDD).IsAssignableFrom(typeT))
                return ScheduleInternal_EDDDDD(ref jobData, null, query, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_DDDDDD).IsAssignableFrom(typeT))
                return ScheduleInternal_DDDDDD(ref jobData, null, query, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_EDDDDDD).IsAssignableFrom(typeT))
                return ScheduleInternal_EDDDDDD(ref jobData, null, query, 1, dependsOn, ScheduleMode.Batched);
            throw new System.ArgumentException("Not supported");
        }
#endif
#if !UNITY_ZEROPLAYER                           
        public static JobHandle ScheduleSingle<T>(this T jobData, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where T : struct, IBaseJobForEach
        {
            var typeT = typeof(T);
            if (typeof(IBaseJobForEach_D).IsAssignableFrom(typeT))
                return ScheduleInternal_D(ref jobData, null, query, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_ED).IsAssignableFrom(typeT))
                return ScheduleInternal_ED(ref jobData, null, query, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_DD).IsAssignableFrom(typeT))
                return ScheduleInternal_DD(ref jobData, null, query, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_EDD).IsAssignableFrom(typeT))
                return ScheduleInternal_EDD(ref jobData, null, query, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_DDD).IsAssignableFrom(typeT))
                return ScheduleInternal_DDD(ref jobData, null, query, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_EDDD).IsAssignableFrom(typeT))
                return ScheduleInternal_EDDD(ref jobData, null, query, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_DDDD).IsAssignableFrom(typeT))
                return ScheduleInternal_DDDD(ref jobData, null, query, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_EDDDD).IsAssignableFrom(typeT))
                return ScheduleInternal_EDDDD(ref jobData, null, query, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_DDDDD).IsAssignableFrom(typeT))
                return ScheduleInternal_DDDDD(ref jobData, null, query, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_EDDDDD).IsAssignableFrom(typeT))
                return ScheduleInternal_EDDDDD(ref jobData, null, query, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_DDDDDD).IsAssignableFrom(typeT))
                return ScheduleInternal_DDDDDD(ref jobData, null, query, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_EDDDDDD).IsAssignableFrom(typeT))
                return ScheduleInternal_EDDDDDD(ref jobData, null, query, -1, dependsOn, ScheduleMode.Batched);
            throw new System.ArgumentException("Not supported");
        }
#endif
#if !UNITY_ZEROPLAYER                           
        public static JobHandle Run<T>(this T jobData, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where T : struct, IBaseJobForEach
        {
            var typeT = typeof(T);
            if (typeof(IBaseJobForEach_D).IsAssignableFrom(typeT))
                return ScheduleInternal_D(ref jobData, null, query, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_ED).IsAssignableFrom(typeT))
                return ScheduleInternal_ED(ref jobData, null, query, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_DD).IsAssignableFrom(typeT))
                return ScheduleInternal_DD(ref jobData, null, query, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_EDD).IsAssignableFrom(typeT))
                return ScheduleInternal_EDD(ref jobData, null, query, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_DDD).IsAssignableFrom(typeT))
                return ScheduleInternal_DDD(ref jobData, null, query, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_EDDD).IsAssignableFrom(typeT))
                return ScheduleInternal_EDDD(ref jobData, null, query, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_DDDD).IsAssignableFrom(typeT))
                return ScheduleInternal_DDDD(ref jobData, null, query, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_EDDDD).IsAssignableFrom(typeT))
                return ScheduleInternal_EDDDD(ref jobData, null, query, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_DDDDD).IsAssignableFrom(typeT))
                return ScheduleInternal_DDDDD(ref jobData, null, query, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_EDDDDD).IsAssignableFrom(typeT))
                return ScheduleInternal_EDDDDD(ref jobData, null, query, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_DDDDDD).IsAssignableFrom(typeT))
                return ScheduleInternal_DDDDDD(ref jobData, null, query, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_EDDDDDD).IsAssignableFrom(typeT))
                return ScheduleInternal_EDDDDDD(ref jobData, null, query, -1, dependsOn, ScheduleMode.Run);
            throw new System.ArgumentException("Not supported");
        }
#endif

#if !UNITY_ZEROPLAYER           
        internal static unsafe JobHandle ScheduleInternal_D<T>(ref T jobData, ComponentSystemBase system, EntityQuery query, int innerloopBatchCount, JobHandle dependsOn, ScheduleMode mode)
            where T : struct
        {
            JobStruct_ProcessInfer_D<T> fullData;
            fullData.Data = jobData;

            var isParallelFor = innerloopBatchCount != -1;
            Initialize(system, query, typeof(T), typeof(JobStruct_Process_D<,>), isParallelFor, ref JobStruct_ProcessInfer_D<T>.Cache, out fullData.Iterator);
                
            var unfilteredChunkCount = fullData.Iterator.m_Length;
            var iterator = JobStruct_ProcessInfer_D<T>.Cache.EntityQuery.GetComponentChunkIterator();

            var prefilterHandle = ComponentChunkIterator.PreparePrefilteredChunkLists(unfilteredChunkCount, iterator.m_MatchingArchetypeList, iterator.m_Filter, dependsOn, mode, out fullData.PrefilterData, out var deferredCountData);
                               
            return Schedule(UnsafeUtility.AddressOf(ref fullData), fullData.PrefilterData, fullData.Iterator.m_Length, innerloopBatchCount, isParallelFor, iterator.RequiresFilter(), ref JobStruct_ProcessInfer_D<T>.Cache, deferredCountData, prefilterHandle, mode);            
        }
#endif

        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        public interface IBaseJobForEach_D : IBaseJobForEach {}

#if !UNITY_ZEROPLAYER
        [StructLayout(LayoutKind.Sequential)]
        private struct JobStruct_ProcessInfer_D<T> where T : struct
        {
            public static JobForEachCache Cache;

            public ProcessIterationData Iterator;
            public T Data;
            
            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;
        }
    
        [StructLayout(LayoutKind.Sequential)]
        internal struct JobStruct_Process_D<T, U0>
            where T : struct, IJobForEach<U0>
            where U0 : struct, IComponentData
        {
            public ProcessIterationData Iterator;
            public T Data;
            
            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;

            [Preserve]
            public static IntPtr Initialize(JobType jobType)
            {
                return JobsUtility.CreateJobReflectionData(typeof(JobStruct_Process_D<T, U0>), typeof(T), jobType, (ExecuteJobFunction) Execute);
            }

            delegate void ExecuteJobFunction(ref JobStruct_Process_D<T, U0> data, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex);

            public static unsafe void Execute(ref JobStruct_Process_D<T, U0> jobData, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex)
            {
                ComponentChunkIterator.UnpackPrefilterData(jobData.PrefilterData, out var chunks, out var entityIndices, out var chunkCount);

                if (jobData.Iterator.m_IsParallelFor)
                {
                    int begin, end;
                    while (JobsUtility.GetWorkStealingRange(ref ranges, jobIndex, out begin, out end))
                        ExecuteChunk(ref jobData, bufferRangePatchData, begin, end, chunks, entityIndices);
                }
                else
                {
                    ExecuteChunk(ref jobData, bufferRangePatchData, 0, chunkCount, chunks, entityIndices);
                }
            }

            static unsafe void ExecuteChunk(ref JobStruct_Process_D<T, U0> jobData, IntPtr bufferRangePatchData, int begin, int end, ArchetypeChunk* chunks, int* entityIndices)
            {
                        var typeLookupCache0 = 0; 

                for (var blockIndex = begin; blockIndex != end; ++blockIndex)
                {    
                    var chunk = chunks[blockIndex];
                    int beginIndex = entityIndices[blockIndex];
                    var count = chunk.Count;
#if ENABLE_UNITY_COLLECTIONS_CHECKS
                    JobsUtility.PatchBufferMinMaxRanges(bufferRangePatchData, UnsafeUtility.AddressOf(ref jobData), beginIndex, beginIndex + count);
#endif       
                        ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex0, ref typeLookupCache0);
                    var ptr0 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly0 == 0, typeLookupCache0, jobData.Iterator.GlobalSystemVersion));
  

                    for (var i = 0; i != count; i++)
                    {
                        jobData.Data.Execute(ref UnsafeUtilityEx.ArrayElementAsRef<U0>(ptr0, i));
                    }
                }
            }
        }
#endif

#if !UNITY_ZEROPLAYER           
        internal static unsafe JobHandle ScheduleInternal_ED<T>(ref T jobData, ComponentSystemBase system, EntityQuery query, int innerloopBatchCount, JobHandle dependsOn, ScheduleMode mode)
            where T : struct
        {
            JobStruct_ProcessInfer_ED<T> fullData;
            fullData.Data = jobData;

            var isParallelFor = innerloopBatchCount != -1;
            Initialize(system, query, typeof(T), typeof(JobStruct_Process_ED<,>), isParallelFor, ref JobStruct_ProcessInfer_ED<T>.Cache, out fullData.Iterator);
                
            var unfilteredChunkCount = fullData.Iterator.m_Length;
            var iterator = JobStruct_ProcessInfer_ED<T>.Cache.EntityQuery.GetComponentChunkIterator();

            var prefilterHandle = ComponentChunkIterator.PreparePrefilteredChunkLists(unfilteredChunkCount, iterator.m_MatchingArchetypeList, iterator.m_Filter, dependsOn, mode, out fullData.PrefilterData, out var deferredCountData);
                               
            return Schedule(UnsafeUtility.AddressOf(ref fullData), fullData.PrefilterData, fullData.Iterator.m_Length, innerloopBatchCount, isParallelFor, iterator.RequiresFilter(), ref JobStruct_ProcessInfer_ED<T>.Cache, deferredCountData, prefilterHandle, mode);            
        }
#endif

        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        public interface IBaseJobForEach_ED : IBaseJobForEach {}

#if !UNITY_ZEROPLAYER
        [StructLayout(LayoutKind.Sequential)]
        private struct JobStruct_ProcessInfer_ED<T> where T : struct
        {
            public static JobForEachCache Cache;

            public ProcessIterationData Iterator;
            public T Data;
            
            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;
        }
    
        [StructLayout(LayoutKind.Sequential)]
        internal struct JobStruct_Process_ED<T, U0>
            where T : struct, IJobForEachWithEntity<U0>
            where U0 : struct, IComponentData
        {
            public ProcessIterationData Iterator;
            public T Data;
            
            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;

            [Preserve]
            public static IntPtr Initialize(JobType jobType)
            {
                return JobsUtility.CreateJobReflectionData(typeof(JobStruct_Process_ED<T, U0>), typeof(T), jobType, (ExecuteJobFunction) Execute);
            }

            delegate void ExecuteJobFunction(ref JobStruct_Process_ED<T, U0> data, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex);

            public static unsafe void Execute(ref JobStruct_Process_ED<T, U0> jobData, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex)
            {
                ComponentChunkIterator.UnpackPrefilterData(jobData.PrefilterData, out var chunks, out var entityIndices, out var chunkCount);

                if (jobData.Iterator.m_IsParallelFor)
                {
                    int begin, end;
                    while (JobsUtility.GetWorkStealingRange(ref ranges, jobIndex, out begin, out end))
                        ExecuteChunk(ref jobData, bufferRangePatchData, begin, end, chunks, entityIndices);
                }
                else
                {
                    ExecuteChunk(ref jobData, bufferRangePatchData, 0, chunkCount, chunks, entityIndices);
                }
            }

            static unsafe void ExecuteChunk(ref JobStruct_Process_ED<T, U0> jobData, IntPtr bufferRangePatchData, int begin, int end, ArchetypeChunk* chunks, int* entityIndices)
            {
                        var typeLookupCache0 = 0; 

                for (var blockIndex = begin; blockIndex != end; ++blockIndex)
                {    
                    var chunk = chunks[blockIndex];
                    int beginIndex = entityIndices[blockIndex];
                    var count = chunk.Count;
#if ENABLE_UNITY_COLLECTIONS_CHECKS
                    JobsUtility.PatchBufferMinMaxRanges(bufferRangePatchData, UnsafeUtility.AddressOf(ref jobData), beginIndex, beginIndex + count);
#endif       
                        var ptrE = (Entity*)UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, false, 0, jobData.Iterator.GlobalSystemVersion));
                        ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex0, ref typeLookupCache0);
                    var ptr0 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly0 == 0, typeLookupCache0, jobData.Iterator.GlobalSystemVersion));
  

                    for (var i = 0; i != count; i++)
                    {
                        jobData.Data.Execute(ptrE[i], i + beginIndex, ref UnsafeUtilityEx.ArrayElementAsRef<U0>(ptr0, i));
                    }
                }
            }
        }
#endif

#if !UNITY_ZEROPLAYER           
        internal static unsafe JobHandle ScheduleInternal_DD<T>(ref T jobData, ComponentSystemBase system, EntityQuery query, int innerloopBatchCount, JobHandle dependsOn, ScheduleMode mode)
            where T : struct
        {
            JobStruct_ProcessInfer_DD<T> fullData;
            fullData.Data = jobData;

            var isParallelFor = innerloopBatchCount != -1;
            Initialize(system, query, typeof(T), typeof(JobStruct_Process_DD<,,>), isParallelFor, ref JobStruct_ProcessInfer_DD<T>.Cache, out fullData.Iterator);
                
            var unfilteredChunkCount = fullData.Iterator.m_Length;
            var iterator = JobStruct_ProcessInfer_DD<T>.Cache.EntityQuery.GetComponentChunkIterator();

            var prefilterHandle = ComponentChunkIterator.PreparePrefilteredChunkLists(unfilteredChunkCount, iterator.m_MatchingArchetypeList, iterator.m_Filter, dependsOn, mode, out fullData.PrefilterData, out var deferredCountData);
                               
            return Schedule(UnsafeUtility.AddressOf(ref fullData), fullData.PrefilterData, fullData.Iterator.m_Length, innerloopBatchCount, isParallelFor, iterator.RequiresFilter(), ref JobStruct_ProcessInfer_DD<T>.Cache, deferredCountData, prefilterHandle, mode);            
        }
#endif

        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        public interface IBaseJobForEach_DD : IBaseJobForEach {}

#if !UNITY_ZEROPLAYER
        [StructLayout(LayoutKind.Sequential)]
        private struct JobStruct_ProcessInfer_DD<T> where T : struct
        {
            public static JobForEachCache Cache;

            public ProcessIterationData Iterator;
            public T Data;
            
            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;
        }
    
        [StructLayout(LayoutKind.Sequential)]
        internal struct JobStruct_Process_DD<T, U0, U1>
            where T : struct, IJobForEach<U0, U1>
            where U0 : struct, IComponentData
            where U1 : struct, IComponentData
        {
            public ProcessIterationData Iterator;
            public T Data;
            
            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;

            [Preserve]
            public static IntPtr Initialize(JobType jobType)
            {
                return JobsUtility.CreateJobReflectionData(typeof(JobStruct_Process_DD<T, U0, U1>), typeof(T), jobType, (ExecuteJobFunction) Execute);
            }

            delegate void ExecuteJobFunction(ref JobStruct_Process_DD<T, U0, U1> data, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex);

            public static unsafe void Execute(ref JobStruct_Process_DD<T, U0, U1> jobData, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex)
            {
                ComponentChunkIterator.UnpackPrefilterData(jobData.PrefilterData, out var chunks, out var entityIndices, out var chunkCount);

                if (jobData.Iterator.m_IsParallelFor)
                {
                    int begin, end;
                    while (JobsUtility.GetWorkStealingRange(ref ranges, jobIndex, out begin, out end))
                        ExecuteChunk(ref jobData, bufferRangePatchData, begin, end, chunks, entityIndices);
                }
                else
                {
                    ExecuteChunk(ref jobData, bufferRangePatchData, 0, chunkCount, chunks, entityIndices);
                }
            }

            static unsafe void ExecuteChunk(ref JobStruct_Process_DD<T, U0, U1> jobData, IntPtr bufferRangePatchData, int begin, int end, ArchetypeChunk* chunks, int* entityIndices)
            {
                        var typeLookupCache0 = 0; 
                        var typeLookupCache1 = 0; 

                for (var blockIndex = begin; blockIndex != end; ++blockIndex)
                {    
                    var chunk = chunks[blockIndex];
                    int beginIndex = entityIndices[blockIndex];
                    var count = chunk.Count;
#if ENABLE_UNITY_COLLECTIONS_CHECKS
                    JobsUtility.PatchBufferMinMaxRanges(bufferRangePatchData, UnsafeUtility.AddressOf(ref jobData), beginIndex, beginIndex + count);
#endif       
                        ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex0, ref typeLookupCache0);
                    var ptr0 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly0 == 0, typeLookupCache0, jobData.Iterator.GlobalSystemVersion));
                        ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex1, ref typeLookupCache1);
                    var ptr1 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly1 == 0, typeLookupCache1, jobData.Iterator.GlobalSystemVersion));
  

                    for (var i = 0; i != count; i++)
                    {
                        jobData.Data.Execute(ref UnsafeUtilityEx.ArrayElementAsRef<U0>(ptr0, i), ref UnsafeUtilityEx.ArrayElementAsRef<U1>(ptr1, i));
                    }
                }
            }
        }
#endif

#if !UNITY_ZEROPLAYER           
        internal static unsafe JobHandle ScheduleInternal_EDD<T>(ref T jobData, ComponentSystemBase system, EntityQuery query, int innerloopBatchCount, JobHandle dependsOn, ScheduleMode mode)
            where T : struct
        {
            JobStruct_ProcessInfer_EDD<T> fullData;
            fullData.Data = jobData;

            var isParallelFor = innerloopBatchCount != -1;
            Initialize(system, query, typeof(T), typeof(JobStruct_Process_EDD<,,>), isParallelFor, ref JobStruct_ProcessInfer_EDD<T>.Cache, out fullData.Iterator);
                
            var unfilteredChunkCount = fullData.Iterator.m_Length;
            var iterator = JobStruct_ProcessInfer_EDD<T>.Cache.EntityQuery.GetComponentChunkIterator();

            var prefilterHandle = ComponentChunkIterator.PreparePrefilteredChunkLists(unfilteredChunkCount, iterator.m_MatchingArchetypeList, iterator.m_Filter, dependsOn, mode, out fullData.PrefilterData, out var deferredCountData);
                               
            return Schedule(UnsafeUtility.AddressOf(ref fullData), fullData.PrefilterData, fullData.Iterator.m_Length, innerloopBatchCount, isParallelFor, iterator.RequiresFilter(), ref JobStruct_ProcessInfer_EDD<T>.Cache, deferredCountData, prefilterHandle, mode);            
        }
#endif

        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        public interface IBaseJobForEach_EDD : IBaseJobForEach {}

#if !UNITY_ZEROPLAYER
        [StructLayout(LayoutKind.Sequential)]
        private struct JobStruct_ProcessInfer_EDD<T> where T : struct
        {
            public static JobForEachCache Cache;

            public ProcessIterationData Iterator;
            public T Data;
            
            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;
        }
    
        [StructLayout(LayoutKind.Sequential)]
        internal struct JobStruct_Process_EDD<T, U0, U1>
            where T : struct, IJobForEachWithEntity<U0, U1>
            where U0 : struct, IComponentData
            where U1 : struct, IComponentData
        {
            public ProcessIterationData Iterator;
            public T Data;
            
            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;

            [Preserve]
            public static IntPtr Initialize(JobType jobType)
            {
                return JobsUtility.CreateJobReflectionData(typeof(JobStruct_Process_EDD<T, U0, U1>), typeof(T), jobType, (ExecuteJobFunction) Execute);
            }

            delegate void ExecuteJobFunction(ref JobStruct_Process_EDD<T, U0, U1> data, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex);

            public static unsafe void Execute(ref JobStruct_Process_EDD<T, U0, U1> jobData, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex)
            {
                ComponentChunkIterator.UnpackPrefilterData(jobData.PrefilterData, out var chunks, out var entityIndices, out var chunkCount);

                if (jobData.Iterator.m_IsParallelFor)
                {
                    int begin, end;
                    while (JobsUtility.GetWorkStealingRange(ref ranges, jobIndex, out begin, out end))
                        ExecuteChunk(ref jobData, bufferRangePatchData, begin, end, chunks, entityIndices);
                }
                else
                {
                    ExecuteChunk(ref jobData, bufferRangePatchData, 0, chunkCount, chunks, entityIndices);
                }
            }

            static unsafe void ExecuteChunk(ref JobStruct_Process_EDD<T, U0, U1> jobData, IntPtr bufferRangePatchData, int begin, int end, ArchetypeChunk* chunks, int* entityIndices)
            {
                        var typeLookupCache0 = 0; 
                        var typeLookupCache1 = 0; 

                for (var blockIndex = begin; blockIndex != end; ++blockIndex)
                {    
                    var chunk = chunks[blockIndex];
                    int beginIndex = entityIndices[blockIndex];
                    var count = chunk.Count;
#if ENABLE_UNITY_COLLECTIONS_CHECKS
                    JobsUtility.PatchBufferMinMaxRanges(bufferRangePatchData, UnsafeUtility.AddressOf(ref jobData), beginIndex, beginIndex + count);
#endif       
                        var ptrE = (Entity*)UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, false, 0, jobData.Iterator.GlobalSystemVersion));
                        ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex0, ref typeLookupCache0);
                    var ptr0 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly0 == 0, typeLookupCache0, jobData.Iterator.GlobalSystemVersion));
                        ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex1, ref typeLookupCache1);
                    var ptr1 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly1 == 0, typeLookupCache1, jobData.Iterator.GlobalSystemVersion));
  

                    for (var i = 0; i != count; i++)
                    {
                        jobData.Data.Execute(ptrE[i], i + beginIndex, ref UnsafeUtilityEx.ArrayElementAsRef<U0>(ptr0, i), ref UnsafeUtilityEx.ArrayElementAsRef<U1>(ptr1, i));
                    }
                }
            }
        }
#endif

#if !UNITY_ZEROPLAYER           
        internal static unsafe JobHandle ScheduleInternal_DDD<T>(ref T jobData, ComponentSystemBase system, EntityQuery query, int innerloopBatchCount, JobHandle dependsOn, ScheduleMode mode)
            where T : struct
        {
            JobStruct_ProcessInfer_DDD<T> fullData;
            fullData.Data = jobData;

            var isParallelFor = innerloopBatchCount != -1;
            Initialize(system, query, typeof(T), typeof(JobStruct_Process_DDD<,,,>), isParallelFor, ref JobStruct_ProcessInfer_DDD<T>.Cache, out fullData.Iterator);
                
            var unfilteredChunkCount = fullData.Iterator.m_Length;
            var iterator = JobStruct_ProcessInfer_DDD<T>.Cache.EntityQuery.GetComponentChunkIterator();

            var prefilterHandle = ComponentChunkIterator.PreparePrefilteredChunkLists(unfilteredChunkCount, iterator.m_MatchingArchetypeList, iterator.m_Filter, dependsOn, mode, out fullData.PrefilterData, out var deferredCountData);
                               
            return Schedule(UnsafeUtility.AddressOf(ref fullData), fullData.PrefilterData, fullData.Iterator.m_Length, innerloopBatchCount, isParallelFor, iterator.RequiresFilter(), ref JobStruct_ProcessInfer_DDD<T>.Cache, deferredCountData, prefilterHandle, mode);            
        }
#endif

        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        public interface IBaseJobForEach_DDD : IBaseJobForEach {}

#if !UNITY_ZEROPLAYER
        [StructLayout(LayoutKind.Sequential)]
        private struct JobStruct_ProcessInfer_DDD<T> where T : struct
        {
            public static JobForEachCache Cache;

            public ProcessIterationData Iterator;
            public T Data;
            
            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;
        }
    
        [StructLayout(LayoutKind.Sequential)]
        internal struct JobStruct_Process_DDD<T, U0, U1, U2>
            where T : struct, IJobForEach<U0, U1, U2>
            where U0 : struct, IComponentData
            where U1 : struct, IComponentData
            where U2 : struct, IComponentData
        {
            public ProcessIterationData Iterator;
            public T Data;
            
            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;

            [Preserve]
            public static IntPtr Initialize(JobType jobType)
            {
                return JobsUtility.CreateJobReflectionData(typeof(JobStruct_Process_DDD<T, U0, U1, U2>), typeof(T), jobType, (ExecuteJobFunction) Execute);
            }

            delegate void ExecuteJobFunction(ref JobStruct_Process_DDD<T, U0, U1, U2> data, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex);

            public static unsafe void Execute(ref JobStruct_Process_DDD<T, U0, U1, U2> jobData, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex)
            {
                ComponentChunkIterator.UnpackPrefilterData(jobData.PrefilterData, out var chunks, out var entityIndices, out var chunkCount);

                if (jobData.Iterator.m_IsParallelFor)
                {
                    int begin, end;
                    while (JobsUtility.GetWorkStealingRange(ref ranges, jobIndex, out begin, out end))
                        ExecuteChunk(ref jobData, bufferRangePatchData, begin, end, chunks, entityIndices);
                }
                else
                {
                    ExecuteChunk(ref jobData, bufferRangePatchData, 0, chunkCount, chunks, entityIndices);
                }
            }

            static unsafe void ExecuteChunk(ref JobStruct_Process_DDD<T, U0, U1, U2> jobData, IntPtr bufferRangePatchData, int begin, int end, ArchetypeChunk* chunks, int* entityIndices)
            {
                        var typeLookupCache0 = 0; 
                        var typeLookupCache1 = 0; 
                        var typeLookupCache2 = 0; 

                for (var blockIndex = begin; blockIndex != end; ++blockIndex)
                {    
                    var chunk = chunks[blockIndex];
                    int beginIndex = entityIndices[blockIndex];
                    var count = chunk.Count;
#if ENABLE_UNITY_COLLECTIONS_CHECKS
                    JobsUtility.PatchBufferMinMaxRanges(bufferRangePatchData, UnsafeUtility.AddressOf(ref jobData), beginIndex, beginIndex + count);
#endif       
                        ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex0, ref typeLookupCache0);
                    var ptr0 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly0 == 0, typeLookupCache0, jobData.Iterator.GlobalSystemVersion));
                        ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex1, ref typeLookupCache1);
                    var ptr1 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly1 == 0, typeLookupCache1, jobData.Iterator.GlobalSystemVersion));
                        ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex2, ref typeLookupCache2);
                    var ptr2 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly2 == 0, typeLookupCache2, jobData.Iterator.GlobalSystemVersion));
  

                    for (var i = 0; i != count; i++)
                    {
                        jobData.Data.Execute(ref UnsafeUtilityEx.ArrayElementAsRef<U0>(ptr0, i), ref UnsafeUtilityEx.ArrayElementAsRef<U1>(ptr1, i), ref UnsafeUtilityEx.ArrayElementAsRef<U2>(ptr2, i));
                    }
                }
            }
        }
#endif

#if !UNITY_ZEROPLAYER           
        internal static unsafe JobHandle ScheduleInternal_EDDD<T>(ref T jobData, ComponentSystemBase system, EntityQuery query, int innerloopBatchCount, JobHandle dependsOn, ScheduleMode mode)
            where T : struct
        {
            JobStruct_ProcessInfer_EDDD<T> fullData;
            fullData.Data = jobData;

            var isParallelFor = innerloopBatchCount != -1;
            Initialize(system, query, typeof(T), typeof(JobStruct_Process_EDDD<,,,>), isParallelFor, ref JobStruct_ProcessInfer_EDDD<T>.Cache, out fullData.Iterator);
                
            var unfilteredChunkCount = fullData.Iterator.m_Length;
            var iterator = JobStruct_ProcessInfer_EDDD<T>.Cache.EntityQuery.GetComponentChunkIterator();

            var prefilterHandle = ComponentChunkIterator.PreparePrefilteredChunkLists(unfilteredChunkCount, iterator.m_MatchingArchetypeList, iterator.m_Filter, dependsOn, mode, out fullData.PrefilterData, out var deferredCountData);
                               
            return Schedule(UnsafeUtility.AddressOf(ref fullData), fullData.PrefilterData, fullData.Iterator.m_Length, innerloopBatchCount, isParallelFor, iterator.RequiresFilter(), ref JobStruct_ProcessInfer_EDDD<T>.Cache, deferredCountData, prefilterHandle, mode);            
        }
#endif

        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        public interface IBaseJobForEach_EDDD : IBaseJobForEach {}

#if !UNITY_ZEROPLAYER
        [StructLayout(LayoutKind.Sequential)]
        private struct JobStruct_ProcessInfer_EDDD<T> where T : struct
        {
            public static JobForEachCache Cache;

            public ProcessIterationData Iterator;
            public T Data;
            
            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;
        }
    
        [StructLayout(LayoutKind.Sequential)]
        internal struct JobStruct_Process_EDDD<T, U0, U1, U2>
            where T : struct, IJobForEachWithEntity<U0, U1, U2>
            where U0 : struct, IComponentData
            where U1 : struct, IComponentData
            where U2 : struct, IComponentData
        {
            public ProcessIterationData Iterator;
            public T Data;
            
            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;

            [Preserve]
            public static IntPtr Initialize(JobType jobType)
            {
                return JobsUtility.CreateJobReflectionData(typeof(JobStruct_Process_EDDD<T, U0, U1, U2>), typeof(T), jobType, (ExecuteJobFunction) Execute);
            }

            delegate void ExecuteJobFunction(ref JobStruct_Process_EDDD<T, U0, U1, U2> data, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex);

            public static unsafe void Execute(ref JobStruct_Process_EDDD<T, U0, U1, U2> jobData, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex)
            {
                ComponentChunkIterator.UnpackPrefilterData(jobData.PrefilterData, out var chunks, out var entityIndices, out var chunkCount);

                if (jobData.Iterator.m_IsParallelFor)
                {
                    int begin, end;
                    while (JobsUtility.GetWorkStealingRange(ref ranges, jobIndex, out begin, out end))
                        ExecuteChunk(ref jobData, bufferRangePatchData, begin, end, chunks, entityIndices);
                }
                else
                {
                    ExecuteChunk(ref jobData, bufferRangePatchData, 0, chunkCount, chunks, entityIndices);
                }
            }

            static unsafe void ExecuteChunk(ref JobStruct_Process_EDDD<T, U0, U1, U2> jobData, IntPtr bufferRangePatchData, int begin, int end, ArchetypeChunk* chunks, int* entityIndices)
            {
                        var typeLookupCache0 = 0; 
                        var typeLookupCache1 = 0; 
                        var typeLookupCache2 = 0; 

                for (var blockIndex = begin; blockIndex != end; ++blockIndex)
                {    
                    var chunk = chunks[blockIndex];
                    int beginIndex = entityIndices[blockIndex];
                    var count = chunk.Count;
#if ENABLE_UNITY_COLLECTIONS_CHECKS
                    JobsUtility.PatchBufferMinMaxRanges(bufferRangePatchData, UnsafeUtility.AddressOf(ref jobData), beginIndex, beginIndex + count);
#endif       
                        var ptrE = (Entity*)UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, false, 0, jobData.Iterator.GlobalSystemVersion));
                        ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex0, ref typeLookupCache0);
                    var ptr0 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly0 == 0, typeLookupCache0, jobData.Iterator.GlobalSystemVersion));
                        ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex1, ref typeLookupCache1);
                    var ptr1 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly1 == 0, typeLookupCache1, jobData.Iterator.GlobalSystemVersion));
                        ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex2, ref typeLookupCache2);
                    var ptr2 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly2 == 0, typeLookupCache2, jobData.Iterator.GlobalSystemVersion));
  

                    for (var i = 0; i != count; i++)
                    {
                        jobData.Data.Execute(ptrE[i], i + beginIndex, ref UnsafeUtilityEx.ArrayElementAsRef<U0>(ptr0, i), ref UnsafeUtilityEx.ArrayElementAsRef<U1>(ptr1, i), ref UnsafeUtilityEx.ArrayElementAsRef<U2>(ptr2, i));
                    }
                }
            }
        }
#endif

#if !UNITY_ZEROPLAYER           
        internal static unsafe JobHandle ScheduleInternal_DDDD<T>(ref T jobData, ComponentSystemBase system, EntityQuery query, int innerloopBatchCount, JobHandle dependsOn, ScheduleMode mode)
            where T : struct
        {
            JobStruct_ProcessInfer_DDDD<T> fullData;
            fullData.Data = jobData;

            var isParallelFor = innerloopBatchCount != -1;
            Initialize(system, query, typeof(T), typeof(JobStruct_Process_DDDD<,,,,>), isParallelFor, ref JobStruct_ProcessInfer_DDDD<T>.Cache, out fullData.Iterator);
                
            var unfilteredChunkCount = fullData.Iterator.m_Length;
            var iterator = JobStruct_ProcessInfer_DDDD<T>.Cache.EntityQuery.GetComponentChunkIterator();

            var prefilterHandle = ComponentChunkIterator.PreparePrefilteredChunkLists(unfilteredChunkCount, iterator.m_MatchingArchetypeList, iterator.m_Filter, dependsOn, mode, out fullData.PrefilterData, out var deferredCountData);
                               
            return Schedule(UnsafeUtility.AddressOf(ref fullData), fullData.PrefilterData, fullData.Iterator.m_Length, innerloopBatchCount, isParallelFor, iterator.RequiresFilter(), ref JobStruct_ProcessInfer_DDDD<T>.Cache, deferredCountData, prefilterHandle, mode);            
        }
#endif

        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        public interface IBaseJobForEach_DDDD : IBaseJobForEach {}

#if !UNITY_ZEROPLAYER
        [StructLayout(LayoutKind.Sequential)]
        private struct JobStruct_ProcessInfer_DDDD<T> where T : struct
        {
            public static JobForEachCache Cache;

            public ProcessIterationData Iterator;
            public T Data;
            
            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;
        }
    
        [StructLayout(LayoutKind.Sequential)]
        internal struct JobStruct_Process_DDDD<T, U0, U1, U2, U3>
            where T : struct, IJobForEach<U0, U1, U2, U3>
            where U0 : struct, IComponentData
            where U1 : struct, IComponentData
            where U2 : struct, IComponentData
            where U3 : struct, IComponentData
        {
            public ProcessIterationData Iterator;
            public T Data;
            
            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;

            [Preserve]
            public static IntPtr Initialize(JobType jobType)
            {
                return JobsUtility.CreateJobReflectionData(typeof(JobStruct_Process_DDDD<T, U0, U1, U2, U3>), typeof(T), jobType, (ExecuteJobFunction) Execute);
            }

            delegate void ExecuteJobFunction(ref JobStruct_Process_DDDD<T, U0, U1, U2, U3> data, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex);

            public static unsafe void Execute(ref JobStruct_Process_DDDD<T, U0, U1, U2, U3> jobData, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex)
            {
                ComponentChunkIterator.UnpackPrefilterData(jobData.PrefilterData, out var chunks, out var entityIndices, out var chunkCount);

                if (jobData.Iterator.m_IsParallelFor)
                {
                    int begin, end;
                    while (JobsUtility.GetWorkStealingRange(ref ranges, jobIndex, out begin, out end))
                        ExecuteChunk(ref jobData, bufferRangePatchData, begin, end, chunks, entityIndices);
                }
                else
                {
                    ExecuteChunk(ref jobData, bufferRangePatchData, 0, chunkCount, chunks, entityIndices);
                }
            }

            static unsafe void ExecuteChunk(ref JobStruct_Process_DDDD<T, U0, U1, U2, U3> jobData, IntPtr bufferRangePatchData, int begin, int end, ArchetypeChunk* chunks, int* entityIndices)
            {
                        var typeLookupCache0 = 0; 
                        var typeLookupCache1 = 0; 
                        var typeLookupCache2 = 0; 
                        var typeLookupCache3 = 0; 

                for (var blockIndex = begin; blockIndex != end; ++blockIndex)
                {    
                    var chunk = chunks[blockIndex];
                    int beginIndex = entityIndices[blockIndex];
                    var count = chunk.Count;
#if ENABLE_UNITY_COLLECTIONS_CHECKS
                    JobsUtility.PatchBufferMinMaxRanges(bufferRangePatchData, UnsafeUtility.AddressOf(ref jobData), beginIndex, beginIndex + count);
#endif       
                        ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex0, ref typeLookupCache0);
                    var ptr0 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly0 == 0, typeLookupCache0, jobData.Iterator.GlobalSystemVersion));
                        ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex1, ref typeLookupCache1);
                    var ptr1 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly1 == 0, typeLookupCache1, jobData.Iterator.GlobalSystemVersion));
                        ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex2, ref typeLookupCache2);
                    var ptr2 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly2 == 0, typeLookupCache2, jobData.Iterator.GlobalSystemVersion));
                        ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex3, ref typeLookupCache3);
                    var ptr3 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly3 == 0, typeLookupCache3, jobData.Iterator.GlobalSystemVersion));
  

                    for (var i = 0; i != count; i++)
                    {
                        jobData.Data.Execute(ref UnsafeUtilityEx.ArrayElementAsRef<U0>(ptr0, i), ref UnsafeUtilityEx.ArrayElementAsRef<U1>(ptr1, i), ref UnsafeUtilityEx.ArrayElementAsRef<U2>(ptr2, i), ref UnsafeUtilityEx.ArrayElementAsRef<U3>(ptr3, i));
                    }
                }
            }
        }
#endif

#if !UNITY_ZEROPLAYER           
        internal static unsafe JobHandle ScheduleInternal_EDDDD<T>(ref T jobData, ComponentSystemBase system, EntityQuery query, int innerloopBatchCount, JobHandle dependsOn, ScheduleMode mode)
            where T : struct
        {
            JobStruct_ProcessInfer_EDDDD<T> fullData;
            fullData.Data = jobData;

            var isParallelFor = innerloopBatchCount != -1;
            Initialize(system, query, typeof(T), typeof(JobStruct_Process_EDDDD<,,,,>), isParallelFor, ref JobStruct_ProcessInfer_EDDDD<T>.Cache, out fullData.Iterator);
                
            var unfilteredChunkCount = fullData.Iterator.m_Length;
            var iterator = JobStruct_ProcessInfer_EDDDD<T>.Cache.EntityQuery.GetComponentChunkIterator();

            var prefilterHandle = ComponentChunkIterator.PreparePrefilteredChunkLists(unfilteredChunkCount, iterator.m_MatchingArchetypeList, iterator.m_Filter, dependsOn, mode, out fullData.PrefilterData, out var deferredCountData);
                               
            return Schedule(UnsafeUtility.AddressOf(ref fullData), fullData.PrefilterData, fullData.Iterator.m_Length, innerloopBatchCount, isParallelFor, iterator.RequiresFilter(), ref JobStruct_ProcessInfer_EDDDD<T>.Cache, deferredCountData, prefilterHandle, mode);            
        }
#endif

        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        public interface IBaseJobForEach_EDDDD : IBaseJobForEach {}

#if !UNITY_ZEROPLAYER
        [StructLayout(LayoutKind.Sequential)]
        private struct JobStruct_ProcessInfer_EDDDD<T> where T : struct
        {
            public static JobForEachCache Cache;

            public ProcessIterationData Iterator;
            public T Data;
            
            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;
        }
    
        [StructLayout(LayoutKind.Sequential)]
        internal struct JobStruct_Process_EDDDD<T, U0, U1, U2, U3>
            where T : struct, IJobForEachWithEntity<U0, U1, U2, U3>
            where U0 : struct, IComponentData
            where U1 : struct, IComponentData
            where U2 : struct, IComponentData
            where U3 : struct, IComponentData
        {
            public ProcessIterationData Iterator;
            public T Data;
            
            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;

            [Preserve]
            public static IntPtr Initialize(JobType jobType)
            {
                return JobsUtility.CreateJobReflectionData(typeof(JobStruct_Process_EDDDD<T, U0, U1, U2, U3>), typeof(T), jobType, (ExecuteJobFunction) Execute);
            }

            delegate void ExecuteJobFunction(ref JobStruct_Process_EDDDD<T, U0, U1, U2, U3> data, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex);

            public static unsafe void Execute(ref JobStruct_Process_EDDDD<T, U0, U1, U2, U3> jobData, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex)
            {
                ComponentChunkIterator.UnpackPrefilterData(jobData.PrefilterData, out var chunks, out var entityIndices, out var chunkCount);

                if (jobData.Iterator.m_IsParallelFor)
                {
                    int begin, end;
                    while (JobsUtility.GetWorkStealingRange(ref ranges, jobIndex, out begin, out end))
                        ExecuteChunk(ref jobData, bufferRangePatchData, begin, end, chunks, entityIndices);
                }
                else
                {
                    ExecuteChunk(ref jobData, bufferRangePatchData, 0, chunkCount, chunks, entityIndices);
                }
            }

            static unsafe void ExecuteChunk(ref JobStruct_Process_EDDDD<T, U0, U1, U2, U3> jobData, IntPtr bufferRangePatchData, int begin, int end, ArchetypeChunk* chunks, int* entityIndices)
            {
                        var typeLookupCache0 = 0; 
                        var typeLookupCache1 = 0; 
                        var typeLookupCache2 = 0; 
                        var typeLookupCache3 = 0; 

                for (var blockIndex = begin; blockIndex != end; ++blockIndex)
                {    
                    var chunk = chunks[blockIndex];
                    int beginIndex = entityIndices[blockIndex];
                    var count = chunk.Count;
#if ENABLE_UNITY_COLLECTIONS_CHECKS
                    JobsUtility.PatchBufferMinMaxRanges(bufferRangePatchData, UnsafeUtility.AddressOf(ref jobData), beginIndex, beginIndex + count);
#endif       
                        var ptrE = (Entity*)UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, false, 0, jobData.Iterator.GlobalSystemVersion));
                        ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex0, ref typeLookupCache0);
                    var ptr0 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly0 == 0, typeLookupCache0, jobData.Iterator.GlobalSystemVersion));
                        ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex1, ref typeLookupCache1);
                    var ptr1 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly1 == 0, typeLookupCache1, jobData.Iterator.GlobalSystemVersion));
                        ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex2, ref typeLookupCache2);
                    var ptr2 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly2 == 0, typeLookupCache2, jobData.Iterator.GlobalSystemVersion));
                        ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex3, ref typeLookupCache3);
                    var ptr3 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly3 == 0, typeLookupCache3, jobData.Iterator.GlobalSystemVersion));
  

                    for (var i = 0; i != count; i++)
                    {
                        jobData.Data.Execute(ptrE[i], i + beginIndex, ref UnsafeUtilityEx.ArrayElementAsRef<U0>(ptr0, i), ref UnsafeUtilityEx.ArrayElementAsRef<U1>(ptr1, i), ref UnsafeUtilityEx.ArrayElementAsRef<U2>(ptr2, i), ref UnsafeUtilityEx.ArrayElementAsRef<U3>(ptr3, i));
                    }
                }
            }
        }
#endif

#if !UNITY_ZEROPLAYER           
        internal static unsafe JobHandle ScheduleInternal_DDDDD<T>(ref T jobData, ComponentSystemBase system, EntityQuery query, int innerloopBatchCount, JobHandle dependsOn, ScheduleMode mode)
            where T : struct
        {
            JobStruct_ProcessInfer_DDDDD<T> fullData;
            fullData.Data = jobData;

            var isParallelFor = innerloopBatchCount != -1;
            Initialize(system, query, typeof(T), typeof(JobStruct_Process_DDDDD<,,,,,>), isParallelFor, ref JobStruct_ProcessInfer_DDDDD<T>.Cache, out fullData.Iterator);
                
            var unfilteredChunkCount = fullData.Iterator.m_Length;
            var iterator = JobStruct_ProcessInfer_DDDDD<T>.Cache.EntityQuery.GetComponentChunkIterator();

            var prefilterHandle = ComponentChunkIterator.PreparePrefilteredChunkLists(unfilteredChunkCount, iterator.m_MatchingArchetypeList, iterator.m_Filter, dependsOn, mode, out fullData.PrefilterData, out var deferredCountData);
                               
            return Schedule(UnsafeUtility.AddressOf(ref fullData), fullData.PrefilterData, fullData.Iterator.m_Length, innerloopBatchCount, isParallelFor, iterator.RequiresFilter(), ref JobStruct_ProcessInfer_DDDDD<T>.Cache, deferredCountData, prefilterHandle, mode);            
        }
#endif

        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        public interface IBaseJobForEach_DDDDD : IBaseJobForEach {}

#if !UNITY_ZEROPLAYER
        [StructLayout(LayoutKind.Sequential)]
        private struct JobStruct_ProcessInfer_DDDDD<T> where T : struct
        {
            public static JobForEachCache Cache;

            public ProcessIterationData Iterator;
            public T Data;
            
            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;
        }
    
        [StructLayout(LayoutKind.Sequential)]
        internal struct JobStruct_Process_DDDDD<T, U0, U1, U2, U3, U4>
            where T : struct, IJobForEach<U0, U1, U2, U3, U4>
            where U0 : struct, IComponentData
            where U1 : struct, IComponentData
            where U2 : struct, IComponentData
            where U3 : struct, IComponentData
            where U4 : struct, IComponentData
        {
            public ProcessIterationData Iterator;
            public T Data;
            
            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;

            [Preserve]
            public static IntPtr Initialize(JobType jobType)
            {
                return JobsUtility.CreateJobReflectionData(typeof(JobStruct_Process_DDDDD<T, U0, U1, U2, U3, U4>), typeof(T), jobType, (ExecuteJobFunction) Execute);
            }

            delegate void ExecuteJobFunction(ref JobStruct_Process_DDDDD<T, U0, U1, U2, U3, U4> data, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex);

            public static unsafe void Execute(ref JobStruct_Process_DDDDD<T, U0, U1, U2, U3, U4> jobData, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex)
            {
                ComponentChunkIterator.UnpackPrefilterData(jobData.PrefilterData, out var chunks, out var entityIndices, out var chunkCount);

                if (jobData.Iterator.m_IsParallelFor)
                {
                    int begin, end;
                    while (JobsUtility.GetWorkStealingRange(ref ranges, jobIndex, out begin, out end))
                        ExecuteChunk(ref jobData, bufferRangePatchData, begin, end, chunks, entityIndices);
                }
                else
                {
                    ExecuteChunk(ref jobData, bufferRangePatchData, 0, chunkCount, chunks, entityIndices);
                }
            }

            static unsafe void ExecuteChunk(ref JobStruct_Process_DDDDD<T, U0, U1, U2, U3, U4> jobData, IntPtr bufferRangePatchData, int begin, int end, ArchetypeChunk* chunks, int* entityIndices)
            {
                        var typeLookupCache0 = 0; 
                        var typeLookupCache1 = 0; 
                        var typeLookupCache2 = 0; 
                        var typeLookupCache3 = 0; 
                        var typeLookupCache4 = 0; 

                for (var blockIndex = begin; blockIndex != end; ++blockIndex)
                {    
                    var chunk = chunks[blockIndex];
                    int beginIndex = entityIndices[blockIndex];
                    var count = chunk.Count;
#if ENABLE_UNITY_COLLECTIONS_CHECKS
                    JobsUtility.PatchBufferMinMaxRanges(bufferRangePatchData, UnsafeUtility.AddressOf(ref jobData), beginIndex, beginIndex + count);
#endif       
                        ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex0, ref typeLookupCache0);
                    var ptr0 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly0 == 0, typeLookupCache0, jobData.Iterator.GlobalSystemVersion));
                        ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex1, ref typeLookupCache1);
                    var ptr1 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly1 == 0, typeLookupCache1, jobData.Iterator.GlobalSystemVersion));
                        ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex2, ref typeLookupCache2);
                    var ptr2 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly2 == 0, typeLookupCache2, jobData.Iterator.GlobalSystemVersion));
                        ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex3, ref typeLookupCache3);
                    var ptr3 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly3 == 0, typeLookupCache3, jobData.Iterator.GlobalSystemVersion));
                        ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex4, ref typeLookupCache4);
                    var ptr4 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly4 == 0, typeLookupCache4, jobData.Iterator.GlobalSystemVersion));
  

                    for (var i = 0; i != count; i++)
                    {
                        jobData.Data.Execute(ref UnsafeUtilityEx.ArrayElementAsRef<U0>(ptr0, i), ref UnsafeUtilityEx.ArrayElementAsRef<U1>(ptr1, i), ref UnsafeUtilityEx.ArrayElementAsRef<U2>(ptr2, i), ref UnsafeUtilityEx.ArrayElementAsRef<U3>(ptr3, i), ref UnsafeUtilityEx.ArrayElementAsRef<U4>(ptr4, i));
                    }
                }
            }
        }
#endif

#if !UNITY_ZEROPLAYER           
        internal static unsafe JobHandle ScheduleInternal_EDDDDD<T>(ref T jobData, ComponentSystemBase system, EntityQuery query, int innerloopBatchCount, JobHandle dependsOn, ScheduleMode mode)
            where T : struct
        {
            JobStruct_ProcessInfer_EDDDDD<T> fullData;
            fullData.Data = jobData;

            var isParallelFor = innerloopBatchCount != -1;
            Initialize(system, query, typeof(T), typeof(JobStruct_Process_EDDDDD<,,,,,>), isParallelFor, ref JobStruct_ProcessInfer_EDDDDD<T>.Cache, out fullData.Iterator);
                
            var unfilteredChunkCount = fullData.Iterator.m_Length;
            var iterator = JobStruct_ProcessInfer_EDDDDD<T>.Cache.EntityQuery.GetComponentChunkIterator();

            var prefilterHandle = ComponentChunkIterator.PreparePrefilteredChunkLists(unfilteredChunkCount, iterator.m_MatchingArchetypeList, iterator.m_Filter, dependsOn, mode, out fullData.PrefilterData, out var deferredCountData);
                               
            return Schedule(UnsafeUtility.AddressOf(ref fullData), fullData.PrefilterData, fullData.Iterator.m_Length, innerloopBatchCount, isParallelFor, iterator.RequiresFilter(), ref JobStruct_ProcessInfer_EDDDDD<T>.Cache, deferredCountData, prefilterHandle, mode);            
        }
#endif

        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        public interface IBaseJobForEach_EDDDDD : IBaseJobForEach {}

#if !UNITY_ZEROPLAYER
        [StructLayout(LayoutKind.Sequential)]
        private struct JobStruct_ProcessInfer_EDDDDD<T> where T : struct
        {
            public static JobForEachCache Cache;

            public ProcessIterationData Iterator;
            public T Data;
            
            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;
        }
    
        [StructLayout(LayoutKind.Sequential)]
        internal struct JobStruct_Process_EDDDDD<T, U0, U1, U2, U3, U4>
            where T : struct, IJobForEachWithEntity<U0, U1, U2, U3, U4>
            where U0 : struct, IComponentData
            where U1 : struct, IComponentData
            where U2 : struct, IComponentData
            where U3 : struct, IComponentData
            where U4 : struct, IComponentData
        {
            public ProcessIterationData Iterator;
            public T Data;
            
            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;

            [Preserve]
            public static IntPtr Initialize(JobType jobType)
            {
                return JobsUtility.CreateJobReflectionData(typeof(JobStruct_Process_EDDDDD<T, U0, U1, U2, U3, U4>), typeof(T), jobType, (ExecuteJobFunction) Execute);
            }

            delegate void ExecuteJobFunction(ref JobStruct_Process_EDDDDD<T, U0, U1, U2, U3, U4> data, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex);

            public static unsafe void Execute(ref JobStruct_Process_EDDDDD<T, U0, U1, U2, U3, U4> jobData, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex)
            {
                ComponentChunkIterator.UnpackPrefilterData(jobData.PrefilterData, out var chunks, out var entityIndices, out var chunkCount);

                if (jobData.Iterator.m_IsParallelFor)
                {
                    int begin, end;
                    while (JobsUtility.GetWorkStealingRange(ref ranges, jobIndex, out begin, out end))
                        ExecuteChunk(ref jobData, bufferRangePatchData, begin, end, chunks, entityIndices);
                }
                else
                {
                    ExecuteChunk(ref jobData, bufferRangePatchData, 0, chunkCount, chunks, entityIndices);
                }
            }

            static unsafe void ExecuteChunk(ref JobStruct_Process_EDDDDD<T, U0, U1, U2, U3, U4> jobData, IntPtr bufferRangePatchData, int begin, int end, ArchetypeChunk* chunks, int* entityIndices)
            {
                        var typeLookupCache0 = 0; 
                        var typeLookupCache1 = 0; 
                        var typeLookupCache2 = 0; 
                        var typeLookupCache3 = 0; 
                        var typeLookupCache4 = 0; 

                for (var blockIndex = begin; blockIndex != end; ++blockIndex)
                {    
                    var chunk = chunks[blockIndex];
                    int beginIndex = entityIndices[blockIndex];
                    var count = chunk.Count;
#if ENABLE_UNITY_COLLECTIONS_CHECKS
                    JobsUtility.PatchBufferMinMaxRanges(bufferRangePatchData, UnsafeUtility.AddressOf(ref jobData), beginIndex, beginIndex + count);
#endif       
                        var ptrE = (Entity*)UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, false, 0, jobData.Iterator.GlobalSystemVersion));
                        ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex0, ref typeLookupCache0);
                    var ptr0 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly0 == 0, typeLookupCache0, jobData.Iterator.GlobalSystemVersion));
                        ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex1, ref typeLookupCache1);
                    var ptr1 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly1 == 0, typeLookupCache1, jobData.Iterator.GlobalSystemVersion));
                        ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex2, ref typeLookupCache2);
                    var ptr2 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly2 == 0, typeLookupCache2, jobData.Iterator.GlobalSystemVersion));
                        ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex3, ref typeLookupCache3);
                    var ptr3 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly3 == 0, typeLookupCache3, jobData.Iterator.GlobalSystemVersion));
                        ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex4, ref typeLookupCache4);
                    var ptr4 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly4 == 0, typeLookupCache4, jobData.Iterator.GlobalSystemVersion));
  

                    for (var i = 0; i != count; i++)
                    {
                        jobData.Data.Execute(ptrE[i], i + beginIndex, ref UnsafeUtilityEx.ArrayElementAsRef<U0>(ptr0, i), ref UnsafeUtilityEx.ArrayElementAsRef<U1>(ptr1, i), ref UnsafeUtilityEx.ArrayElementAsRef<U2>(ptr2, i), ref UnsafeUtilityEx.ArrayElementAsRef<U3>(ptr3, i), ref UnsafeUtilityEx.ArrayElementAsRef<U4>(ptr4, i));
                    }
                }
            }
        }
#endif

#if !UNITY_ZEROPLAYER           
        internal static unsafe JobHandle ScheduleInternal_DDDDDD<T>(ref T jobData, ComponentSystemBase system, EntityQuery query, int innerloopBatchCount, JobHandle dependsOn, ScheduleMode mode)
            where T : struct
        {
            JobStruct_ProcessInfer_DDDDDD<T> fullData;
            fullData.Data = jobData;

            var isParallelFor = innerloopBatchCount != -1;
            Initialize(system, query, typeof(T), typeof(JobStruct_Process_DDDDDD<,,,,,,>), isParallelFor, ref JobStruct_ProcessInfer_DDDDDD<T>.Cache, out fullData.Iterator);
                
            var unfilteredChunkCount = fullData.Iterator.m_Length;
            var iterator = JobStruct_ProcessInfer_DDDDDD<T>.Cache.EntityQuery.GetComponentChunkIterator();

            var prefilterHandle = ComponentChunkIterator.PreparePrefilteredChunkLists(unfilteredChunkCount, iterator.m_MatchingArchetypeList, iterator.m_Filter, dependsOn, mode, out fullData.PrefilterData, out var deferredCountData);
                               
            return Schedule(UnsafeUtility.AddressOf(ref fullData), fullData.PrefilterData, fullData.Iterator.m_Length, innerloopBatchCount, isParallelFor, iterator.RequiresFilter(), ref JobStruct_ProcessInfer_DDDDDD<T>.Cache, deferredCountData, prefilterHandle, mode);            
        }
#endif

        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        public interface IBaseJobForEach_DDDDDD : IBaseJobForEach {}

#if !UNITY_ZEROPLAYER
        [StructLayout(LayoutKind.Sequential)]
        private struct JobStruct_ProcessInfer_DDDDDD<T> where T : struct
        {
            public static JobForEachCache Cache;

            public ProcessIterationData Iterator;
            public T Data;
            
            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;
        }
    
        [StructLayout(LayoutKind.Sequential)]
        internal struct JobStruct_Process_DDDDDD<T, U0, U1, U2, U3, U4, U5>
            where T : struct, IJobForEach<U0, U1, U2, U3, U4, U5>
            where U0 : struct, IComponentData
            where U1 : struct, IComponentData
            where U2 : struct, IComponentData
            where U3 : struct, IComponentData
            where U4 : struct, IComponentData
            where U5 : struct, IComponentData
        {
            public ProcessIterationData Iterator;
            public T Data;
            
            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;

            [Preserve]
            public static IntPtr Initialize(JobType jobType)
            {
                return JobsUtility.CreateJobReflectionData(typeof(JobStruct_Process_DDDDDD<T, U0, U1, U2, U3, U4, U5>), typeof(T), jobType, (ExecuteJobFunction) Execute);
            }

            delegate void ExecuteJobFunction(ref JobStruct_Process_DDDDDD<T, U0, U1, U2, U3, U4, U5> data, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex);

            public static unsafe void Execute(ref JobStruct_Process_DDDDDD<T, U0, U1, U2, U3, U4, U5> jobData, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex)
            {
                ComponentChunkIterator.UnpackPrefilterData(jobData.PrefilterData, out var chunks, out var entityIndices, out var chunkCount);

                if (jobData.Iterator.m_IsParallelFor)
                {
                    int begin, end;
                    while (JobsUtility.GetWorkStealingRange(ref ranges, jobIndex, out begin, out end))
                        ExecuteChunk(ref jobData, bufferRangePatchData, begin, end, chunks, entityIndices);
                }
                else
                {
                    ExecuteChunk(ref jobData, bufferRangePatchData, 0, chunkCount, chunks, entityIndices);
                }
            }

            static unsafe void ExecuteChunk(ref JobStruct_Process_DDDDDD<T, U0, U1, U2, U3, U4, U5> jobData, IntPtr bufferRangePatchData, int begin, int end, ArchetypeChunk* chunks, int* entityIndices)
            {
                        var typeLookupCache0 = 0; 
                        var typeLookupCache1 = 0; 
                        var typeLookupCache2 = 0; 
                        var typeLookupCache3 = 0; 
                        var typeLookupCache4 = 0; 
                        var typeLookupCache5 = 0; 

                for (var blockIndex = begin; blockIndex != end; ++blockIndex)
                {    
                    var chunk = chunks[blockIndex];
                    int beginIndex = entityIndices[blockIndex];
                    var count = chunk.Count;
#if ENABLE_UNITY_COLLECTIONS_CHECKS
                    JobsUtility.PatchBufferMinMaxRanges(bufferRangePatchData, UnsafeUtility.AddressOf(ref jobData), beginIndex, beginIndex + count);
#endif       
                        ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex0, ref typeLookupCache0);
                    var ptr0 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly0 == 0, typeLookupCache0, jobData.Iterator.GlobalSystemVersion));
                        ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex1, ref typeLookupCache1);
                    var ptr1 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly1 == 0, typeLookupCache1, jobData.Iterator.GlobalSystemVersion));
                        ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex2, ref typeLookupCache2);
                    var ptr2 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly2 == 0, typeLookupCache2, jobData.Iterator.GlobalSystemVersion));
                        ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex3, ref typeLookupCache3);
                    var ptr3 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly3 == 0, typeLookupCache3, jobData.Iterator.GlobalSystemVersion));
                        ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex4, ref typeLookupCache4);
                    var ptr4 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly4 == 0, typeLookupCache4, jobData.Iterator.GlobalSystemVersion));
                        ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex5, ref typeLookupCache5);
                    var ptr5 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly5 == 0, typeLookupCache5, jobData.Iterator.GlobalSystemVersion));
  

                    for (var i = 0; i != count; i++)
                    {
                        jobData.Data.Execute(ref UnsafeUtilityEx.ArrayElementAsRef<U0>(ptr0, i), ref UnsafeUtilityEx.ArrayElementAsRef<U1>(ptr1, i), ref UnsafeUtilityEx.ArrayElementAsRef<U2>(ptr2, i), ref UnsafeUtilityEx.ArrayElementAsRef<U3>(ptr3, i), ref UnsafeUtilityEx.ArrayElementAsRef<U4>(ptr4, i), ref UnsafeUtilityEx.ArrayElementAsRef<U5>(ptr5, i));
                    }
                }
            }
        }
#endif

#if !UNITY_ZEROPLAYER           
        internal static unsafe JobHandle ScheduleInternal_EDDDDDD<T>(ref T jobData, ComponentSystemBase system, EntityQuery query, int innerloopBatchCount, JobHandle dependsOn, ScheduleMode mode)
            where T : struct
        {
            JobStruct_ProcessInfer_EDDDDDD<T> fullData;
            fullData.Data = jobData;

            var isParallelFor = innerloopBatchCount != -1;
            Initialize(system, query, typeof(T), typeof(JobStruct_Process_EDDDDDD<,,,,,,>), isParallelFor, ref JobStruct_ProcessInfer_EDDDDDD<T>.Cache, out fullData.Iterator);
                
            var unfilteredChunkCount = fullData.Iterator.m_Length;
            var iterator = JobStruct_ProcessInfer_EDDDDDD<T>.Cache.EntityQuery.GetComponentChunkIterator();

            var prefilterHandle = ComponentChunkIterator.PreparePrefilteredChunkLists(unfilteredChunkCount, iterator.m_MatchingArchetypeList, iterator.m_Filter, dependsOn, mode, out fullData.PrefilterData, out var deferredCountData);
                               
            return Schedule(UnsafeUtility.AddressOf(ref fullData), fullData.PrefilterData, fullData.Iterator.m_Length, innerloopBatchCount, isParallelFor, iterator.RequiresFilter(), ref JobStruct_ProcessInfer_EDDDDDD<T>.Cache, deferredCountData, prefilterHandle, mode);            
        }
#endif

        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        public interface IBaseJobForEach_EDDDDDD : IBaseJobForEach {}

#if !UNITY_ZEROPLAYER
        [StructLayout(LayoutKind.Sequential)]
        private struct JobStruct_ProcessInfer_EDDDDDD<T> where T : struct
        {
            public static JobForEachCache Cache;

            public ProcessIterationData Iterator;
            public T Data;
            
            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;
        }
    
        [StructLayout(LayoutKind.Sequential)]
        internal struct JobStruct_Process_EDDDDDD<T, U0, U1, U2, U3, U4, U5>
            where T : struct, IJobForEachWithEntity<U0, U1, U2, U3, U4, U5>
            where U0 : struct, IComponentData
            where U1 : struct, IComponentData
            where U2 : struct, IComponentData
            where U3 : struct, IComponentData
            where U4 : struct, IComponentData
            where U5 : struct, IComponentData
        {
            public ProcessIterationData Iterator;
            public T Data;
            
            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;

            [Preserve]
            public static IntPtr Initialize(JobType jobType)
            {
                return JobsUtility.CreateJobReflectionData(typeof(JobStruct_Process_EDDDDDD<T, U0, U1, U2, U3, U4, U5>), typeof(T), jobType, (ExecuteJobFunction) Execute);
            }

            delegate void ExecuteJobFunction(ref JobStruct_Process_EDDDDDD<T, U0, U1, U2, U3, U4, U5> data, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex);

            public static unsafe void Execute(ref JobStruct_Process_EDDDDDD<T, U0, U1, U2, U3, U4, U5> jobData, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex)
            {
                ComponentChunkIterator.UnpackPrefilterData(jobData.PrefilterData, out var chunks, out var entityIndices, out var chunkCount);

                if (jobData.Iterator.m_IsParallelFor)
                {
                    int begin, end;
                    while (JobsUtility.GetWorkStealingRange(ref ranges, jobIndex, out begin, out end))
                        ExecuteChunk(ref jobData, bufferRangePatchData, begin, end, chunks, entityIndices);
                }
                else
                {
                    ExecuteChunk(ref jobData, bufferRangePatchData, 0, chunkCount, chunks, entityIndices);
                }
            }

            static unsafe void ExecuteChunk(ref JobStruct_Process_EDDDDDD<T, U0, U1, U2, U3, U4, U5> jobData, IntPtr bufferRangePatchData, int begin, int end, ArchetypeChunk* chunks, int* entityIndices)
            {
                        var typeLookupCache0 = 0; 
                        var typeLookupCache1 = 0; 
                        var typeLookupCache2 = 0; 
                        var typeLookupCache3 = 0; 
                        var typeLookupCache4 = 0; 
                        var typeLookupCache5 = 0; 

                for (var blockIndex = begin; blockIndex != end; ++blockIndex)
                {    
                    var chunk = chunks[blockIndex];
                    int beginIndex = entityIndices[blockIndex];
                    var count = chunk.Count;
#if ENABLE_UNITY_COLLECTIONS_CHECKS
                    JobsUtility.PatchBufferMinMaxRanges(bufferRangePatchData, UnsafeUtility.AddressOf(ref jobData), beginIndex, beginIndex + count);
#endif       
                        var ptrE = (Entity*)UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, false, 0, jobData.Iterator.GlobalSystemVersion));
                        ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex0, ref typeLookupCache0);
                    var ptr0 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly0 == 0, typeLookupCache0, jobData.Iterator.GlobalSystemVersion));
                        ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex1, ref typeLookupCache1);
                    var ptr1 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly1 == 0, typeLookupCache1, jobData.Iterator.GlobalSystemVersion));
                        ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex2, ref typeLookupCache2);
                    var ptr2 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly2 == 0, typeLookupCache2, jobData.Iterator.GlobalSystemVersion));
                        ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex3, ref typeLookupCache3);
                    var ptr3 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly3 == 0, typeLookupCache3, jobData.Iterator.GlobalSystemVersion));
                        ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex4, ref typeLookupCache4);
                    var ptr4 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly4 == 0, typeLookupCache4, jobData.Iterator.GlobalSystemVersion));
                        ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex5, ref typeLookupCache5);
                    var ptr5 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly5 == 0, typeLookupCache5, jobData.Iterator.GlobalSystemVersion));
  

                    for (var i = 0; i != count; i++)
                    {
                        jobData.Data.Execute(ptrE[i], i + beginIndex, ref UnsafeUtilityEx.ArrayElementAsRef<U0>(ptr0, i), ref UnsafeUtilityEx.ArrayElementAsRef<U1>(ptr1, i), ref UnsafeUtilityEx.ArrayElementAsRef<U2>(ptr2, i), ref UnsafeUtilityEx.ArrayElementAsRef<U3>(ptr3, i), ref UnsafeUtilityEx.ArrayElementAsRef<U4>(ptr4, i), ref UnsafeUtilityEx.ArrayElementAsRef<U5>(ptr5, i));
                    }
                }
            }
        }
#endif

    }
}

